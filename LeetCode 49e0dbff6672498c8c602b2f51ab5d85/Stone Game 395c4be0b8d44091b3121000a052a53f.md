# Stone Game

#: 877
Difficult: Medium
Tags: DP, Game, dp-Pyr
link: https://leetcode.com/problems/stone-game/
Priority: Low
Created time: September 10, 2022 11:20 AM
Last edited time: October 12, 2023 2:56 PM
source: jiuzhang, 算高DP下

Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.

The objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.

Alice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.

Assuming Alice and Bob play optimally, return `true` *if Alice wins the game, or* `false` *if Bob wins*.

**Example 1:**

```
Input: piles = [5,3,4,5]
Output: true
Explanation:
Alice starts first, and can only take the first 5 or the last 5.
Say she takes the first 5, so that the row becomes [3, 4, 5].
If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.
If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alice, so we return true.

```

**Example 2:**

```
Input: piles = [3,7,2,3]
Output: true

```

**Constraints:**

- `2 <= piles.length <= 500`
- `piles.length` is **even**.
- `1 <= piles[i] <= 500`
- `sum(piles[i])` is **odd**.

== coin 3

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& nums) {
        int n=nums.size(); if(n==0) {return false;}
        //build prefix sum
        vector<int> prefixSum(nums);
        for(int i=1;i<n;i++){
            prefixSum[i]+=prefixSum[i-1];
        }

        vector<int> f(nums);
        for(int len=2;len<=n;len++){
            for(int l=0,r;r=l+len-1,r<n;l++){
                f[l]=max(
                            getPrefixSum(prefixSum,l,r)-f[l+1], 
                            getPrefixSum(prefixSum,l,r)-f[l]);
            }
        }
        return f.front()*2>accumulate(nums.begin(),nums.end(),0);
    }

    int getPrefixSum(vector<int>& prefixSum, int l, int r){
        return prefixSum[r] - (l==0?0:prefixSum[l-1]);
    }
};
```